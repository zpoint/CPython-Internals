# re

### contents

* [related file](#related-file)
* [how regex work](#how-regex-work)
	* [parse](#parse)
	* [compile](#compile)
	* [match](#match)
* [code detail](#code-detail)
* [reference](#reference)

#### related file
* cpython/Lib/re.py
* cpython/Lib/sre_compile.py
* cpython/Lib/sre_constants.py
* cpython/Lib/sre_parse.py
* cpython/Modules/sre.h
* cpython/Modules/sre_constants.h
* cpython/Modules/sre_lib.h
* cpython/Modules/_sre.c
* cpython/Modules/clinic/_sre.c.h

#### how regex work

what happened when you execute the following code ?

    import re
    re.search("abc\d+abc", "xxabc123abcd") # re.DEBUG)

the call stack

![call_stack](https://github.com/zpoint/CPython-Internals/blob/master/Modules/re/call_stack.png)

the overview of different phases of **re.search**

![overview](https://github.com/zpoint/CPython-Internals/blob/master/Modules/re/overview.png)

let's see what's going on in each step

##### parse

the core code in **parse** phase is in **cpython/Lib/sre_parse.py**

there is a class named **Tokenizer** to split your regex text into token, and **_parse** function is in charge of binding the token with the **sre_constants** code

	# pseudo code
	tokenizer = Tokenizer(pattern, flags)
    while True:
    	next_token = tokenizer.get_next_token()
        if not next_token:
        	break
    	parse(next_token)

let's run the parse phase with regex pattern `abc\d+abc`

	next_token: a
	rest part of token: bc\d+abc
    parse result: [(LITERAL, 97)]

	next_token: b
	rest part of token: c\d+abc
    parse result: [(LITERAL, 97), (LITERAL, 98)]

    next_token: c
    rest part of token: \d+abc
    parse result: [(LITERAL, 97), (LITERAL, 98), (LITERAL, 99)]

    next_token: \d
    rest part of token: +abc
    parse result: [(LITERAL, 97), (LITERAL, 98), (LITERAL, 99), (IN, [(CATEGORY, CATEGORY_DIGIT)])]

now, the **next_token** is `'+'`, the `parse` function will pop whatever in the last parse result, and insert in back with the repeat symbol

	item = parse_result[-1:]
    min, max = 1, MAXREPEAT
    parse_result[-1] = (MAX_REPEAT, (min, max, item))

    next_token: +
    rest part of token: abc
    parse result: [(LITERAL, 97), (LITERAL, 98), (LITERAL, 99), (MAX_REPEAT, (1, MAXREPEAT, [(IN, [(CATEGORY, CATEGORY_DIGIT)])]))]

	next_token: a
	rest part of token: bc
    parse result: [(LITERAL, 97), (LITERAL, 98), (LITERAL, 99), (MAX_REPEAT, (1, MAXREPEAT, [(IN, [(CATEGORY, CATEGORY_DIGIT)])])), (LITERAL, 97)]

	next_token: b
	rest part of token: c
    parse result: [(LITERAL, 97), (LITERAL, 98), (LITERAL, 99), (MAX_REPEAT, (1, MAXREPEAT, [(IN, [(CATEGORY, CATEGORY_DIGIT)])])), (LITERAL, 97), (LITERAL, 98)]

    next_token: c
    rest part of token: None
    parse result: [(LITERAL, 97), (LITERAL, 98), (LITERAL, 99), (MAX_REPEAT, (1, MAXREPEAT, [(IN, [(CATEGORY, CATEGORY_DIGIT)])])), (LITERAL, 97), (LITERAL, 98), (LITERAL, 99)]

##### compile

this is the input of the **compile** phase

    [(LITERAL, 97), (LITERAL, 98), (LITERAL, 99), (MAX_REPEAT, (1, MAXREPEAT, [(IN, [(CATEGORY, CATEGORY_DIGIT)])])), (LITERAL, 97), (LITERAL, 98), (LITERAL, 99)]

the compile function in **sre_compile.py**

    def _code(p, flags):

        flags = p.state.flags | flags
        code = []

        # compile info block
        _compile_info(code, p, flags)

        # compile the pattern
        _compile(code, p.data, flags)

        code.append(SUCCESS)

        return code

the **info block** has the following structure `[INFO, length_of_prefix_code, mask_indicate_whether_has_prefix, min_length_for_the_pattern, max_length_for_the_pattern, prefix1, prefix2..., prefixn, overlap_table_for_prefix]`

after the **_compile_info** function, code becomes

	code == [INFO, 12, 1, 7, MAXREPEAT, 3, 3, 97, 98, 99, 0, 0, 0]

12 means the length of the prefix part excluding the first **INFO** element is 12

1 is the mask value, 1 indicate that the current pattern has literal prefix

7 is the minimal length of the pattern `"abc\d+abc"`, i.e. length of `abc1abc` is 7

MAXREPEAT is the maximum length of the pattern `"abc\d+abc"`, constant **MAXREPEAT** indicate the +∞ (actually, the value is finite)

the first 3 is the length of literal prefix, (`"abc"` here, which is 3)

the second 3 is the length of the prefix_skip, prefix_skip here has the same length as prefix

the following 97, 98, 99 is the prefix `"abc"`

and the following 0, 0, 0 here is generated by the **_generate_overlap_table**

after compile the **info block**, the **pattern** will be compiled in `_compile(code, p.data, flags)`

	for op, av in pattern:
    	compile_and_fill_code_according_to_op_and_av()

	# pattern here is: [(LITERAL, 97), (LITERAL, 98), (LITERAL, 99), (MAX_REPEAT, (1, MAXREPEAT, [(IN, [(CATEGORY, CATEGORY_DIGIT)])])), (LITERAL, 97), (LITERAL, 98), (LITERAL, 99)]

	op: LITERAL av: 97
	code: [LITERAL, 97]

	op: LITERAL av: 98
	code: [LITERAL, 97, LITERAL, 98]

	op: LITERAL av: 99
	code: [LITERAL, 97, LITERAL, 98, LITERAL, 99]

	op: MAX_REPEAT av: (1, MAXREPEAT, [(IN, [(CATEGORY, CATEGORY_DIGIT)])])

now, it comes to a repeat opcode, the code snippest handling this situation is shown

    if op is MAX_REPEAT:
        emit(REPEAT_ONE)
    else:
        emit(MIN_REPEAT_ONE)
    skip = _len(code); emit(0)
    emit(av[0])
    emit(av[1])
    # position 1
    _compile(code, av[2], flags) # recursive call
    emit(SUCCESS)
    code[skip] = _len(code) - skip # change the length
    # position 2

the **code** object in position 1

	code: [LITERAL, 97, LITERAL, 98, LITERAL, 99, REPEAT_ONE, 0, 1, MAXREPEAT]

inside the recursive call, **code** object in position 2, the length now becomes 9

    op: IN av: [(CATEGORY, CATEGORY_DIGIT)]
    code: [LITERAL, 97, LITERAL, 98, LITERAL, 99, REPEAT_ONE, 9, 1, MAXREPEAT, IN, 4, CATEGORY, CATEGORY_UNI_DIGIT, FAILURE, SUCCESS]

	op: LITERAL av: 97
	code: [LITERAL, 97, LITERAL, 98, LITERAL, 99, REPEAT_ONE, 9, 1, MAXREPEAT, IN, 4, CATEGORY, CATEGORY_UNI_DIGIT, FAILURE, SUCCESS, LITERAL, 97]

	op: LITERAL av: 98
	code: [LITERAL, 97, LITERAL, 98, LITERAL, 99, REPEAT_ONE, 9, 1, MAXREPEAT, IN, 4, CATEGORY, CATEGORY_UNI_DIGIT, FAILURE, SUCCESS, LITERAL, 97, LITERAL, 98]

	op: LITERAL av: 99
	code: [LITERAL, 97, LITERAL, 98, LITERAL, 99, REPEAT_ONE, 9, 1, MAXREPEAT, IN, 4, CATEGORY, CATEGORY_UNI_DIGIT, FAILURE, SUCCESS, LITERAL, 97, LITERAL, 98, LITERAL, 99, SUCCESS]

combine the **_compile_info** and **_compile** together, the code to the next phase is

    [INFO, 12, 1, 7, MAXREPEAT, 3, 3, 97, 98, 99, 0, 0, 0, LITERAL, 97, LITERAL, 98, LITERAL, 99, REPEAT_ONE, 9, 1, MAXREPEAT, IN, 4, CATEGORY, CATEGORY_UNI_DIGIT, FAILURE, SUCCESS, LITERAL, 97, LITERAL, 98, LITERAL, 99, SUCCESS]

##### match

the match phase is written in c



#### code detail

follow the call stack to here

	status = sre_search(&state, PatternObject_GetCode(self));

the defination of **sre_search** is

    LOCAL(Py_ssize_t)
    sre_search(SRE_STATE* state, SRE_CODE* pattern)
    {
        if (state->charsize == 1)
            return sre_ucs1_search(state, pattern);
        if (state->charsize == 2)
            return sre_ucs2_search(state, pattern);
        assert(state->charsize == 4);
        return sre_ucs4_search(state, pattern);
    }

if we search for **sre_ucs1_search** in the folder, we can't find anything

	find . -name '*' -exec grep -nHr "sre_ucs1_search" {} \;
    Binary file ./libpython3.8m.a matches
	./Modules/_sre.c:572:        return sre_ucs1_search(state, pattern);

the trick here is for reusing the common part in **sre_lib.h** with different defination

    /* generate 8-bit version */

    #define SRE_CHAR Py_UCS1
    #define SIZEOF_SRE_CHAR 1
    #define SRE(F) sre_ucs1_##F
    #include "sre_lib.h"

    /* generate 16-bit unicode version */

    #define SRE_CHAR Py_UCS2
    #define SIZEOF_SRE_CHAR 2
    #define SRE(F) sre_ucs2_##F
    #include "sre_lib.h"

    /* generate 32-bit unicode version */

    #define SRE_CHAR Py_UCS4
    #define SIZEOF_SRE_CHAR 4
    #define SRE(F) sre_ucs4_##F
    #include "sre_lib.h"

we can find the defination of **search** in **sre_lib.h**

    LOCAL(Py_ssize_t)
    SRE(search)(SRE_STATE* state, SRE_CODE* pattern)

which will be expanded to three different form

	inline Py_ssize_t sre_ucs1_search(SRE_STATE* state, SRE_CODE* pattern)
    inline Py_ssize_t sre_ucs2_search(SRE_STATE* state, SRE_CODE* pattern)
    inline Py_ssize_t sre_ucs4_search(SRE_STATE* state, SRE_CODE* pattern)

when I go inside the expanded **sre_ucs1_search**, I found the [match](#match) phase



#### reference
* [ccs.neu.edu->sre](http://www.ccs.neu.edu/home/shivers/papers/sre.txt)
* [Python's Hidden Regular Expression Gems](http://lucumr.pocoo.org/2015/11/18/pythons-hidden-re-gems/)
* [Understanding Python’s SRE structure](https://blog.labix.org/2003/06/16/understanding-pythons-sre-structure)
* [Get Started with Regex: Regular Expressions Make Easy](https://www.whoishostingthis.com/resources/regex/)
* [Comparing regular expressions in Perl, Python, and Emacs](https://www.johndcook.com/blog/regex-perl-python-emacs/)
